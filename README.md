# Purpose of Omnislash

The purpose of this library is to provide an enhancement layer/separate automation layer on top of Pulumi to allow for more control over the lifecycle of components, and to provide helper code for commons tasks pulumi doesn't. [I raised an issue about the limitations of the Pulumi lifecycle](https://github.com/pulumi/pulumi/issues/20619) which make it impossible to verify that a newly created server is correctly setup prior to deleting the old one, I advise reading it as a primer for this. **Disclaimer**: Ultimately, this is my tool for my own project and I don't intend to support this in any official capacity or take any feature requests for it, nor do I intend to advertise it. 

## Infrastructure As Code (Tool Limitations/Immutable Servers)

- The existing infrastructure as code tools have several issues that don't make them as useful as they should be for using code to simplify deployment/lifecycle concerns.
  - Terraform "decided" that it is an anti-pattern to provision a server with configuration management tools like Ansible to install software/setup your servers in favor of making base images with everything necessary ahead of time. The problem with their decision is that the standard and convenient way to set up a server is to SSH into it, configure the server, upload your software, and so on. If you want to get fancy you manage all of the changes to the server through automated scripts or for example, ansible playbooks... It would be a logical conclusion to take the same traditional approach and to take a ready image from the provider, run your configuration management against it, and do the same again whenever you want something new (a la Immutable Server Pattern/Frying Base Images).
  - Pulumi mentions the immutable server pattern in their articles in this style and even has an incomplete and flawed tutorial for anbsible+wordpress. The issue is: A failure of a command in Pulumi to setup a server (i.e. to run the playbook) can't be used to fail the deployment. The lifecycle of Pulumi isn't strong enough to implement the pattern safely/properly, terraform is better in this regard but the ability to properly simplify things with code is lacking.

## Introduction of Omnislash

Pulumi is an invaluable tool with a valuable ecosystem for managing resources on various providers, while the resources for learning how to use it are arguably lacking, when it comes to simplifying/automating the setup of infrastructure it is entirely possible to use the power of writing good code to simplify things, achieve a separation of concerns, and so on, but this benefit is diminished by the lifecycle and weak component system, and in the current state you **aren't really managing your infrastructure through code**. This is where Omnislash will come in, to automate a simple pattern on top of Pulumi/the automation API, using multiple stacks and a better componenet system and lifecycle there in. The goal is to achieve this in a reliable and idempotent fashion, and where all of it can be achieved through code very similar to the Pulumi code already used. Read the below for some objectives of Omnislash:

- Break the limits of the existing infrastructure as code tooling situation.
- Make it as convenient as it should be to use a configuration management tool to setup a server (i.e. point an ansible playbook to setup a server once deployed).
  - Should the configuration fail, fail the deployment and don't replace the old server, possibly allowing the code to decide what Omnislash should do.  
- Make it possible to replace a resource only once setup or a check has passed to consider the creation done (custom definition of done) (beyond creating it on the underlying API).
